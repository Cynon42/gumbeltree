---
title: "BRMS testing"
author: "Cy Sonkkila"
date: "19/03/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r}
#library(devtools)
#remove.packages(c("StanHeaders", "rstan"))
##install_github("hsbadr/rstan/StanHeaders@develop")
#install.packages("StanHeaders", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
#install.packages("RcppEigen", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
#install_version("RcppEigen", "0.3.3.9.1")
##install_github("hsbadr/rstan/rstan/rstan@develop")
#install.packages("rstan", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
#install_github("paul-buerkner/brms",dependencies = TRUE)
library(brms)
gumbeltree <- custom_family(
  "gumbeltree", dpars = c("mu"), # actually mu is really the sigma for the tree, but the first parameter has to be called sigma,  
                                  # and this is the only parameter that BRMS will be handling
  links = c("log"),

  type = "real",
  vars = c("y_T","X_T","H_T","C_T","mu_T","K_T","L_T","NW_T","NL_T","T_T","grainsize_T") # the additional parameters to run the tree
  #vars = c("grainsize_T")
)

stan_funs_gumbeltree <- "
real partial_sum(real[,] xy_slice,
                   int start,
                   int end,
                   matrix H,
                   vector C,
                   vector mu,
                   real sigma,
                   int K,
                   int L,
                   int NW,
                   int NL,
                   real T) {

  real y[end-start+1] = to_array_1d(xy_slice[,1]);
  matrix[end-start+1 , K] X = to_matrix(xy_slice[,2:(K+1)]);
  matrix[NW,end-start+1] w; //calculation of the weight for each node for each sample
  matrix[NL,end-start+1] temp; //temporary store of tree calculations
                      // after processing, the first row of temp becomes
                      //the estimation of Y given X i.e. y^=F(X)
  int c;// local integer parameter
  int c2;// local integer parameter

  // this is effectively (approximately) choosing which branch of the tree to traverse, based on a cutoff applied to a selected feature
  w=inv_logit(10*((H*X')+rep_matrix(C,end-start+1)));

  // start at the bottom of the tree and work upwards
  // at the end of the loop temp[1] is the result of applying the tree to X[i]
  temp = rep_matrix(mu,end-start+1) ;
  for (j in L:1){
   c=1;
   for (k in 1:(j-1)){
     c = c*2;// can only make integer c = (2^(j-1)) inside a loop
   }

   for (k in 1:c){
     c2=1;
     for (l in 1:j){
       c2 = c2*2;// can only make integer c2 = 2^j inside a loop
     }
     temp[k]=w[k+NW-c2+1] .* temp[2*k-1] + (1-w[k+NW-c2+1]) .* temp[2*k]; // cycling through the tree and calculating which leaf is retained based on w
   }
  }

    return normal_lpdf(y | temp[1]', sigma);// assuming that y is a function that ranges (-inf,+inf)
  }


  real gumbeltree_lpdf(real dummy_sample // at the moment there is no data that BRMS is handling
                  , real sigma
                  , vector y
                  , matrix X
                  , matrix H
                  , vector C
                  , vector mu
                  , int K
                  , int L
                  , int NW
                  , int NL
                  , real T
                  , int grainsize) {
  // we use this function when the reduce sum is our target. This may not be easy right now with BRMS
  real F;
  F  = reduce_sum(partial_sum,
                       to_array_2d(append_col(y,X)),
                       grainsize,
                       H,
                       C,
                       mu,
                       sigma,
                       K,
                       L,
                       NW,
                       NL,
                       T);
  return F;  
  }

real gumbeltree_noreduce_lpdf(vector y
                  , real sigma
                  , matrix X
                  , matrix H
                  , vector C
                  , vector mu
                  , int K
                  , int L
                  , int NW
                  , int NL
                  , real T
                  , int grainsize) {
  // we use this version of the function when using rstan backend in BRMS which can't yet use reduce_sum
  int N = num_elements(y);
  matrix[NW,N] w; //calculation of the weight for each node for each sample
  matrix[NL,N] temp; //temporary store of tree calculations
                      // after processing, the first row of temp becomes
                      //the estimation of Y given X i.e. y^=F(X)
  int c;// local integer parameter
  int c2;// local integer parameter

  // this is effectively (approximately) choosing which branch of the tree to traverse, based on a cutoff applied to a selected feature
  w=inv_logit(10*((H*X')+rep_matrix(C,N)));

  // start at the bottom of the tree and work upwards
  // at the end of the loop temp[1] is the result of applying the tree to X[i]
  temp = rep_matrix(mu,N) ;
  
  for (j in L:1){
   c=1;
   for (k in 1:(j-1)){
     c = c*2;// can only make integer c = (2^(j-1)) inside a loop
   }

   for (k in 1:c){
     c2=1;
     for (l in 1:j){
       c2 = c2*2;// can only make integer c2 = 2^j inside a loop
     }
     temp[k]=w[k+NW-c2+1] .* temp[2*k-1] + (1-w[k+NW-c2+1]) .* temp[2*k]; // cycling through the tree and calculating which leaf is retained based on w
   }
  }

    return normal_lpdf(y | temp[1]', sigma);// assuming that y is a function that ranges (-inf,+inf)
  }

"

stanvars_trf_data = " 
int NL=1;// number of possible leaves
int NW;// number of nodes or weights or choices in the tree

  for (i in 1:L_T){
    NL = NL*2;// can only make integer 2^L inside a loop
  }

  NW=NL-1;
"
stanvars_par = "
  vector[K_T] G[NW];//number of gumbel samples needed to select a feature at each node
  simplex[K_T] P[NW];//probability vector indicating the probability of selecting each feature at each node, each group adds to 1 i.e. simplex

  vector[NW] C; //for each feature selected we need a cutoff point
  vector[NL] mu_T;// mean of Y at each leaf
  real<lower=0> sigma_T;// residual error

"

 stanvars_trf_p = "
 matrix[NW,K_T] H; // one hot to select a feature at each node
 
 for (j in 1:NW){
      H[j] = softmax( (log(P[j])*(T_T^2 + T_T +1) / (T_T+1) + G[j])/T_T)' ;
      // selects a parameter using the approximate one-hot dot producted against a specific X[i], adds a cutoff constant and applies a logistic to return (~0,~1)
  }
 "
 
 priors_text = "
 G[i]~gumbel(0,1); // each vector of gumbels used to create a one-hot
 C~normal(0,1); //features in the design matrix are normalised so the cutoffs should be normalised I suggest
  //P also needs a prior and should have a U shaped dirichlet prior
for (i in 1:NW){
  P[i]~dirichlet(alpha_T);
}
target += reduce_sum(partial_sum,to_array_2d(append_col(y_T,X_T)),grainsize_T,H,C,mu_T,sigma_T,K_T,L_T,NW,NL,T_T)"

# we will use the suffix _T to denote parameters for the tree function to avoid accidentally conflicting a parameter with BRMS
# we are essentially shoehorning our own code into BRMS by force, rendering the main part of the model irelevant at this stage.
# At a later stage, we can envisage BRMS code running a different model as well. e.g a GLM with the tree function providing estimates of the missing variables
stanvars_gumbeltree <- stanvar(scode = stan_funs_gumbeltree, block = "functions")+
                           stanvar(scode = stanvars_trf_data, block = "tdata")+
                           stanvar(scode = stanvars_par, block = "parameters")+
                           stanvar(scode = stanvars_trf_p,block = "tparameters")+
                           stanvar(length(X$y), name = "N_T",scode = "  int N_T;")+ # number of samples
                           stanvar(as.integer(length(X[1,])-1), name = "K_T",scode = "  int K_T;")+ # number of features (minus 1 to exclude y)
                           stanvar(as.matrix(X%>%select(-y)), name = "X_T",scode = "  matrix[N_T,K_T] X_T;")+# here we add the design matrix X directly to the model
                           stanvar(X$y, name = "y_T",scode = "  vector[N_T] y_T;")+# here we add the target samples y directly to the model
                           
                           stanvar(as.integer(4), name = "L_T",scode = "  int L_T;")+ # number of levels in the tree
                           stanvar(1, name = "T_T",scode = "  real T_T;")+ # temperature of the softmax
                           stanvar(0.2, name = "alpha_T",scode = "  real alpha_T;")+ # alpha parameter fo the dirichlet prior for P
                           stanvar(length(X$y)%/%10, name = "grainsize_T",scode = "  int grainsize_T;") #suggested grainsize for the reduce_sum for the tree
   
   # now that I have the componentry to perform a BRMS model with the model. lets call BRMS and ask for the code to see it works
 formula = bf(y ~  1)
 
 priors = c(prior(" for (i in 1:NW){G[i] ~ gumbel(0,1);} // each vector of gumbels used to create a one-hot", check = FALSE)
           ,prior("C~normal(0,1); //features in the design matrix are normalised so the cutoffs should be normalised I suggest", check = FALSE)
           ,prior("for (i in 1:NW){\n   to_vector(P[i]) ~ dirichlet(rep_vector(alpha_T,K_T));\n }//P also needs a prior and should have a U shaped dirichlet prior", check = FALSE)
           ,prior("target += reduce_sum(partial_sum, to_array_2d( append_col(y_T,X_T)), grainsize_T,H,C, mu_T, sigma_T,K_T,L_T,NW,NL,T_T)", check = FALSE)
           )

 stancode =make_stancode(formula
                               #, family = gumbeltree # needed if you want to do something else with the data as well as the tree
                               , stanvars = stanvars_gumbeltree
                               ,data = data.frame(y=1) 
                               ,backend = "cmdstanr"
                               ,threads = threading(20)
                               ,iter = 200
                               ,warmup = 200
                               ,chains = 2
                               ,refresh =10
                               ,max_treedepth=20
                               ,adapt_delta =0.99
                               #,inits = "0"
                               #,thin =1
                               ,prior = priors
) 

stancode # type out the stancode for bug checking before we try to run it

```


Now that we have created BRMS stancode. Lets try to compile it

```{r}

 Test_BRMS =brm(formula
                               #, family = gumbeltree # needed if you want to do something else with the data as well as the tree
                               , stanvars = stanvars_gumbeltree
                               ,data = data.frame(y=1) 
                               ,backend = "cmdstanr"
                               ,threads = threading(20)
                               ,iter = 10
                               ,warmup = 10
                               ,chains = 1
                               ,refresh =1
                               ,max_treedepth=20
                               ,adapt_delta =0.99
                               #,inits = "0"
                               #,thin =1
                               ,prior = priors
) 

```
Readers may note that the BRMS package has effectively been used as a trojan horse to run this code. This shows how much control there is over the BRMS package behaviour if you know how stancode works.

The test has worked so we may now run a longer model that may be amenable to further residuals analysis.

```{r}
BRMS_example =brm(formula
                               #, family = gumbeltree # needed if you want to do something else with the data as well as the tree
                               , stanvars = stanvars_gumbeltree
                               ,data = data.frame(y=1) 
                               ,backend = "cmdstanr"
                               ,threads = threading(20)
                               ,iter = 100
                               ,warmup = 150
                               ,chains = 4
                               ,refresh =10
                               ,max_treedepth=20
                               ,adapt_delta =0.99
                               #,inits = "0"
                               #,thin =1
                               ,prior = priors
) 

```
